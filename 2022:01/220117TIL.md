# Today I Learned

22.01.17(Mon)

# 학습 내용



## 스택 영역 

- 열거형,  구조체, 값타입, 지역변수, 힙 영역을 가리키는 주소

## 힙 영역 

- 클래스, 클로저 등 참조를 가지는 타입


# 기타 중요한 것들 

- String은 값타입(구조체)이지만 character가 힙으로 간접적으로 저장된다. 고로 비효율적임 왜? Heap Allocation이 일어나므로

**근데 값타입인데 왜 참조가 발생해서 Heap Allocation이 일어나지?**

String과 Int를 비교해보면 알 수 있다.

String(Array, Dictionary) 

- 크기가 정해져있지않다. 
- 컴파일 타입에 해당 문자열 크기를 산정을 할 수가 없기 떄문에 메모리에 한정된 자리를 비워놓을 수 없다, 즉 자리를 만들어 놓을 수 없기때문에 힙에 간접적으로 값을 할당한다.

Int - 크기가 정해져있으므로 스택 메모리에 한정된 자리를 만들어놓을 수 있음

Reference Counting

- 클래스 안에 레퍼런스 카운팅이라는 숨겨진 변수가 있다고 생각하자. 
- 해당 클래스를 참조할 때 마다 해당 변수가 카운트(retain)되고, 참조해제될 때 마이너스 카운트(release)가 된다.
- 카운트가 0이면 deinit, 카운트를 올리고 내리는 것도 비용이므로 구조체보다 **비효율**적임

**Copy on write - 필요할 때만 메모리에 복사를 할 것이다.**

- 어떤 구조체를 100만개를 복사해도 구조체 내부 값이 같으면 복사가 이뤄지지 않는다. 똑똑한 놈임

포인터가 커진다 = 가르키는 주소값이 커진다 - high address

- 낮은 주소, 높은 주소 -> 스택은 높은 주소에서 낮은 주소로 감

V table - 수직 상속 관계를 포함하는 테이블(가상)

# 캡처

캡처리스트에서의 값타입 캡쳐 시점은 내가 실행할 코드의 변수(상수) 값, **스택영역!!!!의 값**을 캡쳐해놓는데,이는 클로저가 생성되는 시점에 값을 캡쳐한다.

캡처 리스트시 값타입의 캡쳐시점은 클로저가 생성될 때 이고, 참조 타입의 캡쳐시점은 클로저가 호출될 때 이다.


# 느낀 점
공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 공부하자 공부하자 제발 공부하자 혼자 공부하자 


