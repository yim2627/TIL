# Today I Learned 

22.02.24(Thu)

# 학습내용 

# SwiftUI

## Stack
Combiner(결합자)(ZStack등)에 어느 속성을 지정하거나 변경하면 내부의 컴포넌트에도 설정값이 상속되어서 동시에 변경된다.

ㄴ 따로 설정해주면 그렇지 않음, 아마 상속된 속성을 새로 덮어씌우는 듯

**ZStack**은 사용자쪽으로 쌓아올림

**Hstack**과 **LazyVGrid**가 다른 점은 hstack은 상위 스택이 가진 공간의 빈 공간을 다 차지하려하는데, LazyVGrid는 자신이 가진 gridItem의 사이즈에 맞게 차지함

## MVVM, SwiftUI

진짜 단순하게 생각하면 모델과 뷰는 완전히 독립적임

모델과 뷰의 사이에서 뷰모델이란 것이 있는데, 모델이 변하면 뷰모델에게 알리고, 뷰모델은 모델이 변했어 하고 알린다(해당 뷰모델을 구독한 뷰에게 알림) 그럼 뷰가 뷰모델을 구독하고 있다가, 모델이 변했다는 알림이 오면 뷰를 다시 그린다(변한 정보를 뷰에 뿌린다)

뷰모델은 모델에서 가져온 데이터를 뷰가 원하는 데이터로 변환(해석)하여 전달해줄 수 있음

뷰에서 발생한 이벤트로 인해 모델이 변경되야할 상황일 땐 뷰가 뷰모델에게 "사용자로부터 이러이러한 이벤트(의도)가 발생했어 처리해줘." 하면 뷰모델은 모델을 업데이트, 수정하고 모델이 변했으므로 다시 위 과정을 반복한다(모델: 나 변했어, 뷰모델: ㅇㅋ 애 이렇게 변했대요!!!!, 해당 뷰모델을 구독하고 있는 뷰: 오 쟤 변했네, 변한 데이터(뷰모델이 말한 이렇게)를 다시 뿌려)

뷰는 구조체여서 구조체 프로퍼티를 변하게할 수 없음

선언형 ui - 뷰가 이벤트가 발생했을 때 자신이 어떻게 그려질지를 다 안다

Uikit - 뷰가 이벤트가 발생했을 때 어떻게 그려질지를 모름

연산프로퍼티로 함수로 볼수 있음

ObservableObject
@Published

내가 변하면 알려줄게 (날 관찰하고 있는 사람한테)

@state가 붙은 프로퍼티는 뷰 내부에서만 사용되는 프로퍼티임

@environmentobject 특정 뷰의 하위 모든 뷰에서 model 추적, 관찰, 활용 가능 별도의 주입이 필요없음

가장 상위뷰에 변경사항을 알려주면 상위뷰의 모든 하위뷰에 변경사항을 주입시켜주지 않아도 변경사항을 알 수 있음

stateObject vs observedObject 알아보기

변경사항이 일어났을때 구독하고있는 뷰에게 알려줌, 구독하고 있는 뷰의 하위뷰도 변경사항을 사용하려면 구독하고있는 뷰가 자신의 하위뷰에게 주입시켜줘야함 

하위뷰에서 영향을 받지 않으려고 사용함(둘중에 하나가)

mvvm - 뷰모델이 뷰를 모른다, 뷰는 뷰모델의 값을 꺼내써야함(그러므로 알아야함)


